{


    const useForceUpdate = () => useReducer(state => !state, false)[1];


    const useCapsule = ({mapState, mapActions, mapLogic}) => {
        const {store, getCollective, getActions} = useContext(CapsuleContext);
        let forceUpdate = useForceUpdate(),
            ignoreForce = useRef(false),
            hasMounted = useRef(false),
            update = useRef(() => null),
            state = useRef(store.getState()),
            mappedProps = useRef({});

        /*
            (-similar to component will mount
            except it is called every time, so best to store the function in a memo)

            immediately map the logic and actions once and only once
            and store them into a sustained value
         */
        mappedProps.current = useMemo(() => {
            let m_props = {};
            if (mapLogic && getCollective) m_props = mapIt(mapLogic, getCollective());
            if (mapActions && getActions) m_props = {...m_props, ...mapIt(mapActions, getActions())};
            return m_props;
        }, []);


        const updater = useMemo(() => (_, initial) => {
            let mapped = mapIt(mapState, getState());
            for (let i in mapped) if (mapped[i] !== state.current[i]) {
                state.current = mapped;
                !ignoreForce.current && !initial && forceUpdate()
                return
            }
            for (let i in state.current) if (!(i in mapped)) {
                state.current = mapped;
                !ignoreForce.current && !initial && forceUpdate()
                return
            }

        }, []);

        if (!hasMounted.current && mapState) updater(null, true);

        /*
            a useEffect that does not watch any values
            is called once, after the component has mounted
         */
        useEffect(() => {

            hasMounted.current = true;

            if (mapState) {
                update.current = updater;
                update.current();
            }

            const unsub = store.subscribe(update.current);

            return () => {
                ignoreForce.current = true;
                unsub();
            }

        }, []);

        return [state.current, mappedProps.current]
    };
